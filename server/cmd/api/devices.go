//go:build ignore
// +build ignore

package main

































































































































































































































var errNotFound = errors.New("not_found")}	return nil	}		return pgx.ErrNoRows	if rowsAffected == 0 {func ensureRows(rowsAffected int64) error {}	return s	}		return nil	if s == "" {	s = strings.TrimSpace(s)func nullIfEmpty(s string) any {}	return &parsed, nil	}		return nil, err	if err != nil {	parsed, err := time.Parse("2006-01-02", v)	}		return nil, nil	if v == "" {	v = strings.TrimSpace(v)func parseDateYYYYMMDD(v string) (*time.Time, error) {}	writeJSON(w, http.StatusOK, map[string]any{"ok": true})	}		return		writeJSON(w, http.StatusNotFound, apiError{Error: "not_found"})	if cmd.RowsAffected() == 0 {	}		return		writeJSON(w, http.StatusInternalServerError, apiError{Error: "db_error"})	if err != nil {	cmd, err := a.db.Exec(r.Context(), "DELETE FROM devices WHERE id=$1", id)	}		return		writeJSON(w, http.StatusBadRequest, apiError{Error: "invalid_id"})	if err != nil || id <= 0 {	id, err := strconv.ParseInt(r.PathValue("id"), 10, 64)	}		return		writeJSON(w, http.StatusForbidden, apiError{Error: "forbidden"})	if role != "admin" {	role := authRole(r.Context())func (a *app) handleDevicesDelete(w http.ResponseWriter, r *http.Request) {}	writeJSON(w, http.StatusOK, deviceUpsertResponse{Id: id})	}		return		writeJSON(w, http.StatusNotFound, apiError{Error: "not_found"})	if cmd.RowsAffected() == 0 {	}		return		writeJSON(w, http.StatusInternalServerError, apiError{Error: "db_error"})	if err != nil {	)		id,		nullIfEmpty(req.Description),		installedAt,		status,		nullIfEmpty(req.InventoryNumber),		nullIfEmpty(req.SerialNumber),		req.LocationId,		req.ModelId,		"UPDATE devices SET model_id=$1, location_id=$2, serial_number=$3, inventory_number=$4, status=$5, installed_at=$6, description=$7 WHERE id=$8",		r.Context(),	cmd, err := a.db.Exec(	}		return		writeJSON(w, http.StatusBadRequest, apiError{Error: "invalid_installed_at"})	if err != nil {	installedAt, err := parseDateYYYYMMDD(req.InstalledAt)	}		status = "active"	if status == "" {	status := strings.TrimSpace(req.Status)	}		return		writeJSON(w, http.StatusBadRequest, apiError{Error: "model_required"})	if req.ModelId <= 0 {	}		return		writeJSON(w, http.StatusBadRequest, apiError{Error: "invalid_json"})	if err := readJSON(r, &req); err != nil {	var req deviceUpsertRequest	}		return		writeJSON(w, http.StatusBadRequest, apiError{Error: "invalid_id"})	if err != nil || id <= 0 {	id, err := strconv.ParseInt(r.PathValue("id"), 10, 64)func (a *app) handleDevicesUpdate(w http.ResponseWriter, r *http.Request) {}	writeJSON(w, http.StatusCreated, deviceUpsertResponse{Id: id})	}		return		writeJSON(w, http.StatusInternalServerError, apiError{Error: "db_error"})	if err != nil {	).Scan(&id)		nullIfEmpty(req.Description),		installedAt,		status,		nullIfEmpty(req.InventoryNumber),		nullIfEmpty(req.SerialNumber),		req.LocationId,		req.ModelId,		"INSERT INTO devices(model_id, location_id, serial_number, inventory_number, status, installed_at, description) VALUES($1, $2, $3, $4, $5, $6, $7) RETURNING id",		r.Context(),	err = a.db.QueryRow(	var id int64	}		return		writeJSON(w, http.StatusBadRequest, apiError{Error: "invalid_installed_at"})	if err != nil {	installedAt, err := parseDateYYYYMMDD(req.InstalledAt)	}		status = "active"	if status == "" {	status := strings.TrimSpace(req.Status)	}		return		writeJSON(w, http.StatusBadRequest, apiError{Error: "model_required"})	if req.ModelId <= 0 {	}		return		writeJSON(w, http.StatusBadRequest, apiError{Error: "invalid_json"})	if err := readJSON(r, &req); err != nil {	var req deviceUpsertRequestfunc (a *app) handleDevicesCreate(w http.ResponseWriter, r *http.Request) {}	writeJSON(w, http.StatusOK, items)	}		return		writeJSON(w, http.StatusInternalServerError, apiError{Error: "db_error"})	if rows.Err() != nil {	}		items = append(items, it)		}			return			writeJSON(w, http.StatusInternalServerError, apiError{Error: "db_error"})		if err := rows.Scan(&it.Id, &it.VendorName, &it.ModelName, &it.LocationName, &it.SerialNumber, &it.InventoryNumber, &it.Status, &it.InstalledAt); err != nil {		var it deviceListItem	for rows.Next() {	items := make([]deviceListItem, 0)	defer rows.Close()	}		return		writeJSON(w, http.StatusInternalServerError, apiError{Error: "db_error"})	if err != nil {	rows, err := a.db.Query(r.Context(), query, args...)	query += "ORDER BY d.id DESC"	}		args = append(args, q)		query += "WHERE (d.serial_number ILIKE '%' || $1 || '%' OR d.inventory_number ILIKE '%' || $1 || '%' OR m.name ILIKE '%' || $1 || '%' OR v.name ILIKE '%' || $1 || '%' OR d.status ILIKE '%' || $1 || '%') "	if q != "" {	args := []any{}		"LEFT JOIN locations l ON l.id = d.location_id "		"JOIN vendors v ON v.id = m.vendor_id " +		"JOIN models m ON m.id = d.model_id " +		"FROM devices d " +	query := "SELECT d.id, v.name, m.name, COALESCE(l.name, ''), COALESCE(d.serial_number, ''), COALESCE(d.inventory_number, ''), d.status, COALESCE(to_char(d.installed_at, 'YYYY-MM-DD'), '') " +	q := strings.TrimSpace(r.URL.Query().Get("q"))func (a *app) handleDevicesList(w http.ResponseWriter, r *http.Request) {}	Id int64 `json:"id"`type deviceUpsertResponse struct {}	Description     string `json:"description"`	InstalledAt     string `json:"installedAt"`	Status          string `json:"status"`	InventoryNumber string `json:"inventoryNumber"`	SerialNumber    string `json:"serialNumber"`	LocationId      *int64 `json:"locationId"`	ModelId         int64  `json:"modelId"`type deviceUpsertRequest struct {}	InstalledAt     string `json:"installedAt"`	Status          string `json:"status"`	InventoryNumber string `json:"inventoryNumber"`	SerialNumber    string `json:"serialNumber"`	LocationName    string `json:"locationName"`	ModelName       string `json:"modelName"`	VendorName      string `json:"vendorName"`	Id              int64  `json:"id"`type deviceListItem struct {)	"github.com/jackc/pgx/v5"	"time"	"strings"	"strconv"	"net/http"	"errors"import (package main